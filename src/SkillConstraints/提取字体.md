---
# 这是文章的标题
title: 提取UTF-8字体位图
# 你可以自定义封面图片
# cover: /assets/images/cover1.jpg
# 这是页面的图标
icon: file
# 这是侧边栏的顺序
order: 3
# 设置作者
author: 吾行误述
# 设置写作时间
date: 2024-11-22
# 一个页面可以有多个分类
category:
  - 技束
  - 使用指南
# 一个页面可以有多个标签
tag:
  - 技束
  - 使用指南
# 此页面会在文章列表置顶
sticky: true
# 此页面会出现在星标文章中
star: true
# 你可以自定义页脚
footer: 自定义提取UTF-8字体位图的页脚
# 你可以自定义版权信息
copyright: 无版权
---

自定义提取UTF-8字体位图

<!-- more -->
## 简介


基于 [FreeType](https://freetype.org/index.html) 库的字体提取代码。

应用实例：[墨水屏一言](https://github.com/wuxingwushu/epd2in13_V4)

## 原理说明

简单说明下 [UTF-8编码](https://zh.wikipedia.org/wiki/UTF-8)，其存储一个字的方式是使用可变长度字节。首个字节可以判断当前 字 是占几个字节的，再根据 UTF-8 的存储方式可以转换为对应的整型。

在开始讲解代码前，有必要知道我们需要什么数据，才可以支持我们提取后的数据可以方便使用，这是很重要的，了解清楚这些可以有利于代码和数据结构的设计。也让你查看后续的内容从：提取这些数据有什么用 到 如何提取这些数据。

简单的在屏幕上显示一个字的方法是让 X*Y 的矩形范围内的背景设为黑色，在字体对应的像素显示为白色。我们又知道字是显示在固定大小矩形内的，但是像','这种标点符号不需要存储整个矩形框的内容，只需要存储最小框的内容。这时希望其显示在正确的位置上时，需要存储位图在框的偏移值。这当中关键数据有两种，1.字位图宽高，2.位图像素矩阵的亮灭，3.字位图偏移。
![图片](https://freetype.org/freetype2/docs/glyphs/glyph-metrics-3.svg)![](https://freetype.org/freetype2/docs/glyphs/bitmaps-1.svg)

存储 字位图 只需要存储像素的亮灭，对应 bit 数据的 0，1。所以 char 可以存储 8 个像素点的状态，而不够 8bit 的当完整的 char 存储。再将这些位图数据按照 UTF-8 的大小从小到大的排列存储起来。这时需要：1.数据的偏移量，2.字位图宽高。

```cpp
// 字体位图信息
typedef struct FontInformation
{
    unsigned int Deviation; // 字体在位图数据中的偏移量
    unsigned char x;        // 字体位图宽
    unsigned char y;        // 字体位图高
    char Dx;                // 字体显示位置左右偏移
    char Dy;                // 字体显示位置高度偏移
};
```

UTF-8 当中并不是所有字都是我们需要的，我们只取需要的片段。刚刚也提到 UTF-8 可以转为整数，对应字片段也是连续的。我们只需要将转换的整数减取字片段的偏移值将可以得到字对应的 FontInformation 数组索引。举个简单例子：只取英文大写字位图的数据，A(65)~Z(90) 只有 26 个字母，FontInformation 数组当然也只有 26 个。当需要英文大写字的数据时只需要对应的整型减去 65 将可以得到 FontInformation 数组索引。

```cpp
// UTF-8 字片段范围 对应的 字体位图信息索引表的偏移
typedef struct FontRange
{
    unsigned short Head;      // UTF-8 的 起始范围
    unsigned short Tail;      // UTF-8 的 结束范围
    unsigned short Deviation; // 字体位图索引表的偏移
};
```

将上面内容连起来写份读取字位图数据的伪代码：
```cpp
// 位图数据
char FontData[]{};
// 字体位图信息
FontInformation mFontInformation[]{};
// UTF-8 字片段范围 对应的 字体位图信息索引表的偏移
FontRange mFontRange[FontRangeSize]{};

void UTF8Show(int x, int y, unsigned int utf){
    // 获取字体位图信息的索引
    for(unsigned int i = 0; i < FontRangeSize; ++i){
        // 判断字体在那个字片段范围内
        if((Range[i].Head <= utf) && (utf <=  Range[i].Tail)){
            // 减去对应的偏移
            utf -= Range[i].Deviation;
        }
    }

    // 从高位往下读 bit 数据
    char bitPos = 0x80;
    // 存储读取完的字节数
    unsigned int bitDeviation = 0;
    // 获取对应字的信息
    FontInformation Info = mFontInformation[utf];
    // 开始循环读取位图信息
    for(unsigned char ix = 0; ix < Info.x; ++ix){
        for(unsigned char iy = 0; iy < Info.y; ++iy){
            // 获取当前像素亮灭
            bool B = (FontData[Info.Deviation + bitDeviation] & bitPos) > 0;
            // 准备读取下一 bit 数据
            bitPos >>= 1;
            // 读完一字节
            if(bitPos == 0){
                // 返回高位
                bitPos = 0x80;
                // 偏移到下一字节
                ++bitDeviation;
            }

            /*
                B : 代表像素亮灭
                ix, iy : 像素位置（使用时需要自己 + x,y 位置偏移）
            */
        }
    }
}
```

## 代码讲解
大部分代码都有注释说明其作用，所以这里就只对代码片段做大致说明和需要注意的部分变量参数。[查看源代码](https://github.com/wuxingwushu/TestRoutineSet/blob/main/TTF_bin/main.cpp)

初始化&配置 FreeType
```cpp
    FT_Library library;
    FT_Face face;

    // 初始化 FreeType
    if (FT_Init_FreeType(&library))
    {
        std::cerr << "Failed to initialize FreeType library" << std::endl;
        return -1;
    }

    // 设置矢量字体文件
    if (FT_New_Face(library, "./Minecraft_AE.ttf", 0, &face))
    {
        std::cerr << "Failed to load font" << std::endl;
        FT_Done_FreeType(library);
        return -1;
    }

    // 设置字体大小
    if (FT_Set_Char_Size(face, 0, 16 * 64, 72, 72))
    {
        std::cerr << "Failed to set character size" << std::endl;
        FT_Done_Face(face);
        FT_Done_FreeType(library);
        return -1;
    }
```

创建&打开 存储数据的文件
```cpp
    // 打开二进制文件
    std::ofstream FontInfo("FontInfo.bin", std::ios::out | std::ios::binary); // 字体位图索引表 bit文件
    std::ofstream FontData("FontData.bin", std::ios::out | std::ios::binary); // 字体位图 bit文件
    std::ofstream file("FontFunction.h");                                     // 字体位图读取函数

    // 文件是否都打开了
    if (!FontData || !FontInfo || !file)
    {
        std::cout << "无法打开文件！" << std::endl;
        return -1;
    }
```

在 UTF8Range数组 添加你需要的 UTF-8字 的范围，字体范围可以在[这个网站查看](https://www.cnblogs.com/findumars/p/6833786.html)。添加 FontRange信息 当中的第三个参数 Deviation 可以默认为 0。（设置为任意值也没有影响，因为这个数是程序后续决定的，并不是手动设置的）
```cpp
    // 添加你需要的UTF8字体范围
    FontRange UTF8Range[] = {
        {0x0020, 0x007F, 0}, // Basic Latin
        {0x2000, 0x206F, 0}, // General Punctuation
        {0x2E80, 0x2FDF, 0}, // CJK Radicals Supplement ~ Kangxi Radicals
        {0x3000, 0x30FF, 0}, // CJK Symbols and Punctuation ~ Hiragana ~ Katakana
        {0x31F0, 0x31FF, 0}, // Katakana Phonetic Extensions
        {0x3400, 0x4DBF, 0}, // CJK Unified Ideographs Extension A
        {0x4E00, 0x9FFF, 0}, // CJK Unified Ideographs
        {0xF900, 0xFAFF, 0}, // CJK Compatibility Ideographs
        {0xFE30, 0xFE4F, 0}, // CJK Compatibility Forms
        {0xFF00, 0xFFEF, 0}, // Halfwidth and Fullwidth Forms
    };
```

计算字范围的偏移值
```cpp
    // 字体 UTF8 的范围偏移值
    unsigned short ADDDeviation = 0;
    for (size_t iR = 0; iR < sizeof(UTF8Range) / sizeof(FontRange); ++iR)
    {
        // 获取当中字范围的偏移值
        UTF8Range[iR].Deviation = UTF8Range[iR].Head - ADDDeviation;
        // 偏移值 累加 这个范围内的字数
        ADDDeviation += (UTF8Range[iR].Tail - UTF8Range[iR].Head) + 1;
    }
```

获取字的信息和位图
```cpp
    // 打印打前正在处理的字
     std::cout << converter.to_bytes(i);
    // 获取对应字的索引
    FT_UInt glyph_index = FT_Get_Char_Index(face, i);
    // 是否存在这个字的矢量信息
    if (FT_Load_Glyph(face, glyph_index, FT_LOAD_DEFAULT))
    {
        // 不存这个字的矢量信息，数据链不完整
        std::cout << "存在缺失字的矢量信息！" << std::endl;
        return -1;
    }
    // 获取字的信息
    FT_Render_Glyph(face->glyph, FT_RENDER_MODE_NORMAL);
    Info.Deviation = Index;                                   // 获取字位图偏移量
    Info.x = face->glyph->bitmap.width;                       // 获取位图宽
    Info.y = face->glyph->bitmap.rows;                        // 获取位图高
    Info.Dx = face->glyph->bitmap_left;                       // 获取位图位置 x 偏移
    Info.Dy = 15 - face->glyph->bitmap_top;                   // 获取位图位置 y 偏移

    face->glyph->bitmap.buffer; // 这是位图数据指针大小为 [face->glyph->bitmap.width * face->glyph->bitmap.rows] 的数组
```