---
# 这是文章的标题
title: ‌汉诺塔程序解题
# 你可以自定义封面图片
# cover: /assets/images/cover1.jpg
# 这是页面的图标
icon: file
# 这是侧边栏的顺序
order: 3
# 设置作者
author: 吾行误述
# 设置写作时间
date: 2024-12-05
# 一个页面可以有多个分类
category:
  - 技束
# 一个页面可以有多个标签
tag:
  - 技束
# 此页面会在文章列表置顶
sticky: true
# 此页面会出现在星标文章中
star: true
# 你可以自定义页脚
footer: 组织语言中...
# 你可以自定义版权信息
copyright: 无版权
---

‌汉诺塔程序解题

<!-- more -->

## ‌汉诺塔规则
1. 大圆盘不可以压小圆盘
2. 圆盘只可以一个一个取
3. 圆盘只可以取对应柱子最顶上的一圆盘
4. 将 0柱子 的塔全部移动到 2柱子 上为胜利


## 解题思路

我们知道想要移动最下层的圆盘就要将上面所有的圆盘都移动开来，因为最下层的圆盘最大不可以压在其他圆盘上，所以可以得知其他圆盘都在同一个柱子上。如果我们移动的是N层‌汉诺塔，那希望移动最下层的圆盘就需要先将上面N-1层高的‌汉诺塔移动到一个柱子上，移动最下面的圆盘后再将刚刚移动的那N-1层‌汉诺塔移动到最大圆盘上面。（因为移动最上面的所有圆盘，都比最底下的圆盘小，所以没有因为最底下的圆盘导致出现不能移动的柱子）

![](image/‌汉诺塔.svg)

仔细观察可以得知 N层塔 的移动可以从 N-1层塔 的步骤得来。
从而推理出解题公式： **(N)层塔移动 = (N-1)层塔移动 + 最底层移动 + (N-1)层塔移动**

```
1层‌汉诺塔最简解题方法： 0->2
2层‌汉诺塔最简解题方法： 0->1, 0->2, 1->2
3层‌汉诺塔最简解题方法： 0->2, 0->1, 2->1, 0->2, 1->0, 1->2, 0->2
4层‌汉诺塔最简解题方法： 0->1, 0->2, 1->2, 0->1, 2->0, 2->1, 0->1, 0->2, 1->2, 1->0, 2->0, 1->2, 0->1, 0->2, 1->2
```

使用公式分析上面不同的层数的解题步骤

```
1层塔移动 = 0层塔移动 + 1层塔移动(0->2) + 0层塔移动
2层塔移动 = 1层塔移动(0->1) +  最底层移动(0->2) + 1层塔移动(1->2)
3层塔移动 = 2层塔移动(0->2, 0->1, 2->1) + 最底层移动(0->2) + 2层塔移动(1->0, 1->2, 0->2)
4层塔移动 = 3层塔移动(0->1, 0->2, 1->2, 0->1, 2->0, 2->1, 0->1) + 最底层移动(0->2) + 3层塔移动(1->2, 1->0, 2->0, 1->2, 0->1, 0->2, 1->2)
```

分析后会发现，N层塔移动的解题步骤当中的N-1层塔移动 **不等于** N-1层塔移动。为什么相同层数移动步骤不一样呢，那是因为从不同柱子移动到不同的目的地柱子导致的：
以三层塔移动步骤来分析
```
2层塔移动(0->1, 0->2, 1->2)                 ： 是从 0柱子 移动到 2柱子。
3层塔移动步骤当中的2层塔移动(0->2, 0->1, 2->1)： 是从 0柱子 移动到 1柱子。
3层塔移动步骤当中的2层塔移动(1->0, 1->2, 0->2)： 是从 1柱子 移动到 2柱子。
```

那在最简步骤怎么选择移动到那个柱子呢？（注意：这里只以塔在 0柱子 被移动为例）
我们先观察N层‌汉诺塔的每层圆盘的初次移动到哪？最底下的一层（第N层圆盘）在整个步骤当中只移动一次那就是（0->2），这是从上面条件已知的。
第N-1层圆盘的初次移动是（0->1）是为了给第N层圆盘留2柱子的位置。
第N-1层圆盘可以移动到1柱子的位置是因为第N-2层圆盘初次移动在2柱子的位置。
第N-2层圆盘可以移动到2柱子的位置是因为第N-3层圆盘初次移动在1柱子的位置。
第N-3层圆盘可以移…………
以此类推可以得出第一步放 1柱子 还是 2柱子，是根据剩余需要移动的‌汉诺塔层数决定的。奇数：放2柱子，偶数：放1柱子。

![](image/‌汉诺塔初次.svg)

结合上面所有信息就可以写程序了：

## 解题程序
```cpp
#include <iostream>
#include <vector>

#define TaSize 6 // ‌汉诺塔数量（最大255<unsigned char>）

/**
 * @brief ‌汉诺塔移塔步骤生成函数
 * @param Ta 塔的数组[3][对应塔的信息]
 * @param t1 被移动的塔（柱子编号）
 * @param t2 空地（柱子编号）
 * @param t3 移动到的位置（柱子编号） */
void LHT_YT(std::vector<std::vector<unsigned char>> Ta, unsigned char t1, unsigned char t2, unsigned char t3)
{
   if ((Ta[t1].size() == 0) && (Ta[t2].size() == 0))
   {
      return;// 结束了
   }
   bool swBool = false; // 记录是否调换过
   if ((Ta[t1].size() % 2) == 0)// 通过奇偶判断放那个位置
   { 
      std::swap(t2, t3);
      swBool = true;
   }
   // 将 t1柱子 顶上的一圆盘移到 t3柱子 去
   Ta[t3].push_back(Ta[t1].back());
   Ta[t1].pop_back();
   std::cout << (int)t1 << "->" << (int)t3 << std::endl;

   // 判断 t2柱子 是否有塔, 有塔就将塔移动到 t3柱子
   if (Ta[t2].size() > 0)
   {
      // 将 t2柱子的塔 复制一份
      std::vector<std::vector<unsigned char>> LTa;
      LTa.resize(3);
      LTa[t2] = Ta[t2];
      // 将 t2柱子的塔 移动到 t3柱子
      LHT_YT(LTa, t2, t1, t3);

      // 因为上面的移动是在复制体进行的，需要手动获取移动后的结果
      for (size_t i = 0; i < Ta[t2].size(); i++)
      {
         Ta[t3].push_back(Ta[t2][i]);
      }
      Ta[t2].clear();
   }
   // 如果调换过就调换回来
   if (swBool)
   {
      std::swap(t2, t3);
   }
   // 继续执行下一层塔
   LHT_YT(Ta, t1, t2, t3);
}

int main()
{
   std::vector<std::vector<unsigned char>> mTa;
   mTa.resize(3);
   for (int i = 0; i < TaSize; ++i)
   {
      mTa[0].push_back(TaSize - i);
   }
   LHT_YT(mTa, 0, 1, 2);
   return 0;
}
```
